

@ 추상(미완성된) 클래스
-> 객체 생성을 막아놓은 클래스
	ex) public abstract class 클래스명{  }
-> 클래스 안에 추상메소드를 가지고 있으면, 그 클래스는 반드시 추상클래스가 되어야 함
	=> 추상 클래스를 상속받은 후손 클래스는 반드시 부모의 추상메소드를 완성
	시켜야 되는 강제성이 부여됨
	=> 후손은 추상메소드를 반드시 오버라이딩 해서 선언 해두어야 함

	
	※ 추상(미완성된) 메소드
	-> 메소드의 헤드(Head)만 있고, 몸체(Body : 내용)가 없는 메소드
	ex) public abstract 반환자료형 메소드명([자료형 매개변수]);
	// 표준화된 인터페이스를 제공할 목적으로 추상메소드를 사용 됨
	// 메소드 사용의 통일성을 확보하고 메소드 제작을 강제화 함

-> 추상클래스는 추상메소드가 없어도 명시 할 수 있음 : 객체 생성 방지 목적




@ 인터페이스 (interface)
-> 상수형 필드와 추상 메소드로만 구성된 추상 클래스의 변형체
-> 클래스에 추상메소드를 포함시키는 구조보다는 메소드의 통일성을 부여하기 위해서
추상 메소드만 따로 모아놓은 추상 클래스
-> 인터페이스의 멤버는 반드시 public 임
	- 필드는 상속이 아닌 인터페이스 것이기 때문에 public으로 되어 있어야 사용 가능함


	[public] interface 인터페이스명
	{
		// 상수형 필드 : 필드명은 대문자로 지어줌
		// 그냥 작성하여도 자동으로 static final이 됨
		public static final 자료형 필드명 = 초기값;

		// 추상 메소드
		[public abstract] 반환형 메소드명([자료형 매개변수]);
	}

	※ 상수형 필드는 자동으로 선언되어 있는 것이고, 
	추상 메소드는 후손이 꼭 만들어야 하는 것임



@ 인터페이스의 사용 : 상속을 통해서 후손이 부모 인터페이스의 추상메소드를
	완성시키는 방식임.
-> interface를 상속 할때에는 implements 라는 키워드를 사용 해야 함


	* 클래스의 상속 : extends 클래스명 (단일상속)
	* 인터페이스의 상속 : implements 인터페이스명 (다중상속 가능)

	class 클래스명 extends 클래스명 implements 인터페이스명
	{}

	class 클래스명 implements 인터페이스명, 인터페이스명, 인터페이스명
	{}

	※ 인터페이스간에도 상속이 가능함, 다중 상속 가능함
		interface 인터페이스명 extends 부모인터페이스명 {}


















