	 
	 @ is a 상속
	 -> A is a B : A는 B다 라는 뜻
	 -> 즉, A는 B를 상속 받아 결국 A는 B의 것을 가지게 됨
	 -> 객체지향 프로그래밍에서는 상속이라는 개념을 사용함
	 	※ 상속이라는 뜻은 유산 상속과 같음
	 	    가령 아버지(부모)가 아들(자식)에게 유산을 상속하게 되면 
	 	    아들은 아버지의 유산을 상속 받게 되어 재산이 늘어 나게 됨
	 
	 ex)	    
		 아버지의 재산 : 10억
		 아들의 재산 : 1억
		 
		 ## 생각해보자 ##
		 만약 아버지가 아들에게 유산 상속을 하게 되었을 때 아들의 재산은 얼마가 되겠는가
		 
	  ※ 상속 받은 필드가 private이라면
	-> 자식 클래스에서 상속 받은 필드가 private으로 되어 있으면 직접 적인 접근은 불가능 
	-> 그러나 상속 받은 필드에 접근할 필요성이 있을 때에는 크게 3가지 방법을 통해 접근 할 수 있음
	
	1. 필드를 private으로 선언하지 않고 protected로 선언하는 방법
	2. setter를 이용하는 방법 - 부모의 setter를 이용해야 함
	3. 부모 생성자를 호출하는 방법(키워드는 super)
		- super 키워드는 부모 생성자를 호출하는 키워드
		- 자식 생성자에서 사용 할 수 있는 키워드
		
		 
	@ 다형성
	-> 객체 지향 프로그래밍의 3대 특징 중 하나
	-> 상속을 이용한 기술임
	-> 상속 관계에 있는 부모, 자식 클래스 간에 부모 타입은 모든 후손 타입을 받아 줄 수 있음
	-> 부모 클래스 타입의 레퍼런스가 후손 객체의 주소를 저장할 수 있다는 뜻이 됨
			-후손 객체 안에 부모 멤버가 포함되어 있기 때문에 가능함
	-> 한가지 가 여러가지 형태를 가지고 있는것을 다형성이라고 표현 함
	->부모 래퍼런스는 자식 객체의 주소를 저장할 수 있음
			※ 주의할점 : 부모 레퍼런스를 통해 객체의 접근 시 부모가 가지고 있는 메소드만 사용 할 수 있음
			(만약 부모 레퍼런스이지만 자식의 메소드를 호출하려면 다운캐스팅을 해야 함)	
	
	@ 메소드 오버라이딩
	-> 부모 클래스의 메소드를 상속받지 않고 자신이 재정의 할 때 사용하는 것
	
	ex)
	public class Animal{
		public void crying(){
			System.out.println("크와왕~");
		}
	}
	
	public class Tiger extends Animal
	{
		public void howling(){
			System.out.println("어흥~!!");
		}
	}
	
	public class TestMain{
		public static void main(String[] args){
			Tiger t = new Tiger();
			t.howling(); // 어떠한 결과가 출력 될까?
		}
	}
	
	@ 애너테이션 (어노테이션) - Java Annotation
	-> 애너테이션은 자바 소스코드에 추가 하여 사용할 수 있는 메타데이터의 일종
	-> '@' 기호를 붙여 사용하며 가상 머신에게 해당 문법에 대해 알려줌
	->  메소드 오버라이딩 시에는 @Override를 명시하여 오버라이드 된 메소드임을
		JVM에게 알려줌 (생략 하여도 자동으로 @Override가 명시됨)
		
	@ abstract (추상화)
		-> abstract 라는 키워드는 추상이라는 의미를 가지고 있는 키워드임
		-> 메소드를 abstract로 만들경우 부모 클래스는 자신을 상속 받는 자식들에게
		해당 메소들르 강제적으로 생성하라는 의미가 됨
		(부모는 기능이 없는 메소드를 만든 것 이고 해당 기능을 가진 메소드를 상속 받은 자식들이 오버라이딩해서 정의하라는 의미)
		-> abstract 메소드를 포함하고 있는 클래스는 불완전한 클래스가 됨0
		(기능이 없는 메소드를 가지고 있는 클래스가 객체화 되면 안됨)
		-> 그렇기 때문에 abstract 메소들르 포함하고 있는 클래스는 객체화 할 수 없도록
		클래스 명 앞에 abstract 키워드를 붙여서 추상클래스로 선언 해야 함
		(추상 클래스는 객체화 할 수 없는 클래스 라는 것을 의미 함)
		
	ex)
	
	public abstract class Aniaml{
		public abstract void howling();
		// howling 메소드는 추상 메소드가 됨 (몸체(기능)이 없는 메소드)
		// 즉, 자신을 상속 받은 자식 클래스에게 해당 메소드를
		// 강제적으로 오버라이딩(재정의) 해서 사용하라는 뜻을 말함
	}	
	-> Animal을 상속 받은 클래스들은 무조건 howiling 메소드를 오버라이딩 해야 함
	
		
		
		
		
		
		
		
		
		
		
		
	