	
	
	 @ this 키워드
	 -> 클래스 생성시 setter, getter 메소드를 만들게 되면 멤버변수와 매개변수의 이름이 동일할 경우 
	 	해당 변수는 가장 가까운 변수를 지목하는 상황이 됨
	 	
 	ex)
 		private String name;
 		public void setName(String name){
 			this.name = name;
 		}
 		
 		-> this 라는 키워드를 사용하여 자기 자신을 지칭하게 됨
	 
	 @ 클래스 다이어 그램
	 -> 우리가 제작된 클래스를 그림으로 표현하는 것
	 -> 클래스 다이어 그램에는 멤버변수(필드), 메소드를 표현 함 
		 
	 @ 생성자와 소멸자
	 -> 생성자는 class를 바탕으로 객체가 생성될 때 자동으로 호출되는 메소드
	 -> 소멸자는 객체가 소멸할 때 자동으로 호출되는 메소드
	 -> 타언어에서는 생성자와 소멸자가 존재하지만 'Java" 라는 언어는 특성상
	 	생성자는 있지만 소멸자는 존재하지 않음
 	
 	* 소멸자가 존재하지 않게 된 이유
 	: 타 언어(C++)에서는 사용한 메모리에 대한 정리도 개발자가 직접 해야 했음
 	(new를 사용하면 사용한 객체를 지울때는 delete를 코딩 해야 했음
 	JVM이 직접 관리 하도록 하기 위해여 GC(Garbage Collector)가 존재함
 	GC는 JVM에서 사용하는 메모리 꽉차기 전에 자동으로 특정 알고리즘에 의해서 메모리 정리 역할을 해주고 있음
 	즉, 자바는 개발자에게 메모리 관리까지 생각하여 코딩하지 말고
 	프로그램 개발에만 집중할 수 있도록 만든 개발자 중심의 언어라고 볼 수 있음
 	
 	@ 생성자
 	-> 객체가 성성될 때 자동으로 호출 되는 메소드
 	-> 일반적으로 객체가 제대로 동작 할 수 있게 준비하는 역할 (기본 데이터 입력)
 	-> 메소드 이름은 클래스 이름과 같아야 하며 리턴 값은 존재하지 않음
 		(리턴 값은 넣을 수가 없기 떄문에 리턴 데이터 타입 명시를 하지 않아도 됨)
 	-> 주의할점 : 생성자 코드를 수정하게 되면 디폴트(기본) 생성자가 없어지게 됨
 	-> 일반 메소드와 마찬가지로 오버로딩이 가능 함
 	
 		※ 디폴트 생성자 : 매개변수 존재하지 않는 생성자
 		
 	@ 메소드 오버로딩
 	-> 자바의 메소드 호출에는 메소드명과 매개변수 개수, 타입을 보고 호출할 메소드를 찾음
 	-> 그렇기 때문에 같은 이름의 메소드명이라고 하더라도 매개변수의 개수가 다르거나 타입이 다르다면 동일한 메소드명으로 제작이 가능함
 	
 	@ 지역변수, 전역변수, 정적변수
 	-> 우리가 클래스 안에서 생성하는 변수들은 크게 3가지가 있음 (지역, 전역, 정적(클래스) 변수)
 	-> 지역변수 : 해당 지역(메소드)안에서만 사용가능한 변수
 		-> 메소드가 호출될 때 생성되고 메소드가 종료될때 메모리에서 삭제됨
 		-> Stack 메모리 영역에  생성
 		
 	-> 전역변수 : 해당 클래스안에서 사용 가능한 변수 (객체 생성 시 해당 객체만 사용 가능)
 		-> 객체가 생성될 때 생성되고 객체가 소멸할 때 메모리에서 삭제 됨
 		-> Heap 메모리 영역에 생성
 		
 	-> 정적변수 : 객체와 상관없이 사용 가능한 변수
 		-> private으로 생성 시 실제 생성된 객체끼리 공유
 		-> public으로 생성시 어디서든 사용 가능
 		-> 프로그램 시작 시 생성되고 프로그램 종료시 삭제 됨
 		-> Static 메모리 영역에 생성
 		
 	ex)
 		public class Test{
 			private int globalVal; // 전역변수
 			private static int staticVal; // 정적변수
 			public void local(){
 				int localVal; // 지역변수 
 			}
 		}
 	
 	
 	