	
	
	 @ this 키워드
	 -> 클래스 생성시 setter, getter 메소드를 만들게 되면 멤버변수와 매개변수의 이름이 동일할 경우 
	 	해당 변수는 가장 가까운 변수를 지목하는 상황이 됨
	 	
 	ex)
 		private String name;
 		public void setName(String name){
 			this.name = name;
 		}
 		
 		-> this 라는 키워드를 사용하여 자기 자신을 지칭하게 됨
	 
	 @ 클래스 다이어 그램
	 -> 우리가 제작된 클래스를 그림으로 표현하는 것
	 -> 클래스 다이어 그램에는 멤버변수(필드), 메소드를 표현 함 
		 
	 @ 생성자와 소멸자
	 -> 생성자는 class를 바탕으로 객체가 생성될 때 자동으로 호출되는 메소드
	 -> 소멸자는 객체가 소멸할 때 자동으로 호출되는 메소드
	 -> 타언어에서는 생성자와 소멸자가 존재하지만 'Java" 라는 언어는 특성상
	 	생성자는 있지만 소멸자는 존재하지 않음
 	
 	* 소멸자가 존재하지 않게 된 이유
 	: 타 언어(C++)에서는 사용한 메모리에 대한 정리도 개발자가 직접 해야 했음
 	(new를 사용하면 사용한 객체를 지울때는 delete를 코딩 해야 했음
 	JVM이 직접 관리 하도록 하기 위해여 GC(Garbage Collector)가 존재함
 	GC는 JVM에서 사용하는 메모리 꽉차기 전에 자동으로 특정 알고리즘에 의해서 메모리 정리 역할을 해주고 있음
 	즉, 자바는 개발자에게 메모리 관리까지 생각하여 코딩하지 말고
 	프로그램 개발에만 집중할 수 있도록 만든 개발자 중심의 언어라고 볼 수 있음
 	
 	@ 생성자
 	-> 객체가 성성될 때 자동으로 호출 되는 메소드
 	-> 일반적으로 객체가 제대로 동작 할 수 있게 준비하는 역할 (기본 데이터 입력)
 	-> 메소드 이름은 클래스 이름과 같아야 하며 리턴 값은 존재하지 않음
 		(리턴 값은 넣을 수가 없기 떄문에 리턴 데이터 타입 명시를 하지 않아도 됨)
 	-> 주의할점 : 생성자 코드를 수정하게 되면 디폴트(기본) 생성자가 없어지게 됨
 	-> 일반 메소드와 마찬가지로 오버로딩이 가능 함
 	
 		※ 디폴트 생성자 : 매개변수 존재하지 않는 생성자
 		
 	@ 메소드 오버로딩
 	-> 자바의 메소드 호출에는 메소드명과 매개변수 개수, 타입을 보고 호출할 메소드를 찾음
 	-> 그렇기 때문에 같은 이름의 메소드명이라고 하더라도 매개변수의 개수가 다르거나 타입이 다르다면 동일한 메소드명으로 제작이 가능함
 	
 	@ 지역변수, 전역변수, 정적변수
 	-> 우리가 클래스 안에서 생성하는 변수들은 크게 3가지가 있음 (지역, 전역, 정적(클래스) 변수)
 	-> 지역변수 : 해당 지역(메소드)안에서만 사용가능한 변수
 		-> 메소드가 호출될 때 생성되고 메소드가 종료될때 메모리에서 삭제됨
 		-> Stack 메모리 영역에  생성
 		
 	-> 전역변수 : 해당 클래스안에서 사용 가능한 변수 (객체 생성 시 해당 객체만 사용 가능)
 		-> 객체가 생성될 때 생성되고 객체가 소멸할 때 메모리에서 삭제 됨
 		-> Heap 메모리 영역에 생성
 		
 	-> 정적변수 : 객체와 상관없이 사용 가능한 변수
 		-> private으로 생성 시 실제 생성된 객체끼리 공유
 		-> public으로 생성시 어디서든 사용 가능
 		-> 프로그램 시작 시 생성되고 프로그램 종료시 삭제 됨
 		-> Static 메모리 영역에 생성
 		
 	ex)
 		public class Test{
 			private int globalVal; // 전역변수
 			private static int staticVal; // 정적변수
 			public void local(){
 				int localVal; // 지역변수 
 			}
 		}
 		
 	@ final 키워드
 	-> 상수화 시키는 키워드
 	-> 변수 데이터 타입 앞에 final 키워드를 붙이면 상수화 시키겠다 라는 의미가 됨
 	
 	ex) final int A = 10; // 상수 a 
 		      int a = 10; 
 		      
 	-> static을 명시하면서 final 키워드를 붙이게 되면 어디서든 사용가능한 상수 라는 의미가 됨
 	ex) public static final int RED = 0xFF0000;
 	
 	※ 꼭 기억해야 하는것은 final 변수는 명명규칙에 의하여 대문자를 사용
 	
 	@ 메소드에 사용되는 static 키워드 와 final 키워드
 	-> 우리가 정적을 의미하는 키워드인 static을 메소드에 명시하게 되면
 	       해당 메소드는 이제 더이상 객체의 메소드가 아닌 클래스의 메소드가 되기 때문에 따로
 	       객체를 만들고 사용하지 않아도 됨(즉석 사용이 가능함)
 	       
 	-> 메소드에 final 키워드를 붙이게 되면 메소드 오버라이딩을 막겠다는 의미
 	-> 클래스에 final 키워드를 붙이게 되면 상속을 막겠다는 의미
 	
 	
 	@ has a 포함 관계
 	-> A has a B : A안에는 B가 포함되어있다
 	-> 자바에서 포함이란 재활용하고 싶은 클래스의 객체를 멤버변수로 선언하는 방법임
 	-> A 클래스 안에  B클래스 멤버 변수로 사용하겠다 라는 것
 	-> 자바에서는 데이터를 표현하는 클래스와 해당 데이터를 운영하는 클래스를 별도로 두고 있음
 		※ 기존에는 하나의 클래스 안에 데이터 저장과 운용을 한번에 했었음
 		
 		- 데이터가 되는 클래스 : Entitiy, VO, DTO
 		- 데이터를 컨트롤 하는 클래스 : Controller
 		
 	public Student{
 		private String name;
 		public void setName(String name) { this.name = name; } 
 		public String getName() { return this.name; } 
 	}
 	
 	public StuMgr{
 		private Student;
 	}
 	
 	
 	
 	