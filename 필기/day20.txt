
 @ Generic(제네릭)
 -> 제네릭이란 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
 -> JDK 1.5 부터 제공되는 기능
 
  ex)
  
	  public class GenericEx <T> {
	
		private T data;
		
		public GenericEx(T data) { this.data = data; }
		public T getData() { return data; }
	}
	
  -> 제네릭은 데이터 타입을 바로 정해놓지 않고 동적으로 처리하기 위한 문법
  -> 하지만 중요한 점은 타입은 Class 타입만 가능함 (기본 자료형은 불가능)
  
  
  @ 제네릭을 이용한 여러개의 데이터 타입 명시
  -> 제네릭은 하나의 클래스당 1개 이상 사용이 가능함
  -> 즉, 여러개의 타입을 동시에 선언이 가능하다는 의미
  -> 단, 동일한 것을 연속으로 사용할 순 없음 (ex. <T, T>)
  
  
  @ 제네릭의 생략
  -> 제네릭은 정의 후 사용할 때 생략 할 수 있음
  
  public static void main(String [] args){
  		GenericEx s1 = new GenericEx(100, "Hello");
  		GenericEx<integer, String> s2 = new GenericEx<Integer, String> (100, "Hello");
  }
  
  -> 제네릭의 정석적인 사용법은 사용 시에 형을 지정해 주어야 함
  -> 제네릭은 사용 시에 데이터형을 생략하면 자동으로 데이터형을 입력 처리 해주기 때문에 데이터만 넘겨주어도 처리 할  수 있음
  
  
  @ 제네릭의 제한
  -> 제네릭은 해당 클래스로 데이터가 들어올 때 타입이 정해지는 것
  -> 그러다 보면 개발자가 의도치 않은 데이터 타입이 올 수도 있음
  -> 그렇기 때문에 제네릭을 설정 시 데이터 타입을 제한 할 수 있음
  -> 제네릭은 3가지로 설정할 수 있음
  	- <?>	: 제한없음, 모든 데이터 타입이 가능함
  	- <? extends T> : 상한제한, T와 그 자손들만 가능
  	- <? super T> : 하한제한, T와 그 조상들만 가능
  	
  	
  @ Collection
  -> 메모리상에서 자료를 구조적으로 처리하는 방법을 자료구조라고 함
  -> 컬렉션(Collection)은 자바에서 제공하는 자료구조를 담당하는 프레임워크임
  		※ 프레임 워크 : 개발을 수월하게 하기 위해 다양한 기능을 제공하는 도구
  -> 추가 , 삭제, 정렬  등의 기능처리가 간단하게 해결되어 자료구조적 알고리즘
  	  사용자가 별도로 구현할 필요가 없음
  	  
  	  
  @ 자료 구조란?
  -> 데이터(자료)를 메모리에서 구조적으로 처리하는 방법론  
  
  @ 배열의 한계점
  1. 한번 크기를 지정하면 변경할 수 없음
  -> 공간의 크기가 부족하면 에러가 발생하기 때문에, 할당시 넉넉한 크기로 할당 하게 됨
  		(메모리 낭비)
  -> 필요에 따라 늘어나가너 줄일 수 없음
  
  2. 배열에 기록된 데이터에 대한 중간 위치의 추가, 삭제가 어려움
  -> 데이터를 중간에 추가 하려면 새로운 배열을 만들고 각 데이터들을 뒤로 하나씩 이동한 후 중간에 넣어 주어야 함
  -> 데이터를 중간에 삭제 하려면 새로운 배열을 만들고 데이터를 삭제 후 남은 각 데이터들을 앞으로 한 칸씩 가져와야 함
  
  3. 한 타입의 데이터만 저장이 가능함 (다양한 데이터 타입 처리는 불가능)
 
 
  @ 컬렉션(Collection)의 장점
 
  1. 저장하는 크기의 제약이 없음
  	(데이터를 추가할 때마다 자동으로 늘어남)
  
  2. 추가, 삭제, 정렬 등의 기능처리가 간단하게 해결 됨
  -> 자료를 구조적으로 처리하는 자료구조가 내장되어 알고리즘 구현이 필요 없음
  
  3. 여러 타입을 저장할 수 있음
  -> 객체만 저장할 수 있음
  -> 필요에 따라 기본 자료형을 저장해야 하는 경우에는 Wrapper 클래스를 사용 함
  
  @ 컬렉션 주요 인터페이스
  -> 컬렉션은 크게 2개의 인터페이스로 나눌 수 있음
  -> Collection, Map
  
  ## Collection ##
  - List 계열 (ArrayList, Vector, LinkedList)
  		-> 순소를 유지하고 저장
  		-> 중복 저장 가능
  		
  - set 계열 (HashSet, TreeSet)
  		-> 순서를 유지하지 않고 저장
  		-> 중복 저장이 안됨
  		
  - Queue 계열 
  		-> FIFO 구조
  		-> 들어온 순서대로 데이터를 저장하고 뺄 수 있음
  		
  	
  ## Map ##
  -> List와 Set을 합친 구조
  -> 키와 쌍이 되는 값으로 저장됨
  -> 키는 중복 저장 안됨 (Set 속성)
  -> 값은 중복 저장 가능 (List 속성)
  -> 종류 : HashMap, HashTable, TreeMap, Properties
  
  @ ArrayList
  -> ArrayList는 기존 배열과는 사용법이 조금 다름
  	(배열은 크기가 정해져 있으니 ArrayList는 크기가 정해져 있지 않음)

	ex) 
		ArrayList<String> aList = new ArrayList<String>();

		aList.add("Hell");
		aList.add("Java");
		aList.add("haha");
		aList.add("hoho");
		aList.add("heheh");

		for (String str : aList) {
			System.out.println(str);
		}
		
	-> 이렇듯 사용하는 방법을 보면 데이터를 추가할 때 add 메소드를 통해 데이터를 하나하나 추가 할 수 있음
	-> 데이터의 개수는 size 메소드를 통해 알아 올 수 있음
	-> get 메소드를 통해 데이터를 꺼내 올 수 있음
  
  ## add 메소드 ##
  -> 데이터 추가 메소드
  -> add(Element)
  
  ## size 메소드 ##
  -> 저장된 데이터의 개수를 담고 있는 메소드 
  
  ## get메소드 ##
  -> 저장된 데이터를 꺼내오는 메소드
  -> get(index)
  
  ## remove 메소드 ##
  -> 저장된 데이터를 삭제함 (인자 값으로 index 번호를 넘겨주면 됨)
  -> remove(index)
  
  ## clear 메소드 ##
  -> 저장된 모든 데이터 삭제
  
  ## set 메소드  ##
  -> 저장된 데이터를 교체
  -> set(index, Element)
  		※ Element는 객체
  
  
  @ 정렬(sort)
  -> 우리가 Collection을 쓰는 이유 중의 하나가 정렬을 쉽게 하기 위한 것도 있음
  -> ArrayList는 자동정렬 메소드인 sort를 지원함
  -> 이 때 Collections.sort(객체명) 메소드를 사용 하여 정렬 함
  		- Collections.sort 메소드는 static 메소드
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  	  
  	  
  	  
  	  
  	  